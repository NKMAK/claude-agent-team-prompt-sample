# Claude Code: Skills + Agent Teams による設計ワークフロー

## このリポジトリについて

Claude Code の Agent Teams でソフトウェア設計を自動化する実験です。

**以前のアプローチ**では、各エージェントの役割・制約・出力フォーマットをすべてプロンプトに直接記述していました。しかしこの方法ではエージェントが意図通りに動かない問題がありました。

**現在のアプローチ**では、**Skills（動的ナレッジ参照）+ CLAUDE.md（ワークフロー定義）+ Agent Teams（協調実行）の3層構成**に変更しました。

---

## なぜ変えたのか：旧アプローチの問題

旧構成（`agent-teams/design-planning/`）では以下の問題がありました。

### 1. プロンプトの肥大化

各エージェントのロール定義（`requirements-agent.md`, `planning-agent.md` 等）にすべてを詰め込んでいた。

- 責任範囲、使用可能ツール、制約、チェックリスト、フォーマット、ベストプラクティス、他エージェントとの協調方法…
- 1エージェントあたり100〜300行のプロンプト
- **4エージェント分が同時にコンテキストに載る = トークンの無駄遣い**

### 2. 固定ロール問題

「Requirements Agent」「Planning Agent」「Architect Agent」「Reviewer Agent」という4つの役割がハードコードされていた。

- この4つ以外の使い方ができない
- 簡単なタスクでも4エージェント全員が起動してしまう
- **必要なのは知識であって、固定された役割ではない**

### 3. 指示の一貫遵守が困難

プロンプトが長大になるほど、エージェントが全指示を守りにくくなる。

- 後半の指示が無視されがち
- 出力フォーマットがブレる
- チェックリストが形骸化する

---

## 新アプローチ：3層構成

```
.claude/
├── CLAUDE.md                          # ワークフロー定義（常時読み込み）
├── skills/                            # 必要なときだけ読み込むナレッジ
│   ├── requirements-gathering.md
│   ├── task-planning.md
│   ├── architecture-design.md
│   └── design-review.md
└── design-output/                     # 成果物の出力先
    └── [project-name]/
        ├── requirement-doc.md
        ├── plan-doc.md
        ├── architecture-doc.md
        └── review-doc.md
```

### 各レイヤーの役割

| レイヤー | 何をするか | いつ読み込まれるか |
|----------|-----------|-------------------|
| **CLAUDE.md** | ワークフロー全体の方針を定義。「設計タスクではこれらのスキルを使え」と指示 | **常時**（セッション開始時に自動で読み込み） |
| **Skills** | 要件定義・計画・設計・レビューの具体的な手法、フォーマット、チェックリスト | **必要なときだけ**（タスクに応じてエージェントが参照） |
| **Agent Teams** | 複数エージェントの並行実行と協調 | **実行時**（TeamCreate + Task で動的に構成） |

### Skills がなぜ効くか

旧アプローチでは「Requirements Agent のプロンプトに要件定義の全知識を載せる」だった。

新アプローチでは「汎用エージェントを起動し、タスク説明で『`/task-planning` スキルを参照せよ』と指示する」に変わった。

**つまり、エージェントの役割を事前に固定するのではなく、タスクに応じてスキルを割り当てることで、その場で専門エージェントを作り上げる。**

これにより：

- **トークン節約**: 全知識を常にコンテキストに載せるのではなく、必要なスキルだけ読み込む
- **柔軟性**: 3エージェントでも1エージェントでも良い。タスクの規模に合わせて構成を変えられる
- **指示の遵守率向上**: 1スキル = 1つの責務に絞った簡潔なナレッジなので、エージェントが守りやすい

---

## 実際にやったこと：TODOアプリ設計の検証

### 指示の流れ

```
リーダー（自分）
  │
  ├─ 1. /requirements-gathering スキルを参照して要件定義を作成
  │     → requirement-doc.md を出力
  │
  ├─ 2. TeamCreate で「todo-design」チームを作成
  │
  ├─ 3. TaskCreate で3つのタスクを作成（依存関係付き）
  │     Task #1: タスク計画作成（/task-planning スキルを参照せよ）
  │     Task #2: アーキテクチャ設計作成（/architecture-design スキルを参照せよ）
  │     Task #3: 設計レビュー（/design-review スキルを参照せよ）← #1, #2 の完了待ち
  │
  ├─ 4. planner と architect を並行で起動（Task tool で spawn）
  │     各エージェントには「まずスキルファイルを読め」と指示
  │
  └─ 5. #1, #2 完了後に reviewer を起動
        reviewer は plan-doc と architecture-doc をレビュー
```

### リーダーが各エージェントに出した指示（実際のプロンプト抜粋）

**planner への指示**:
```
あなたは計画担当エージェント「planner」です。
1. まずスキルファイルを読み込む: .claude/skills/task-planning.md
2. 要件ドキュメントを読み込む: .claude/design-output/todo-app/requirement-doc.md
3. スキルのガイド・フォーマット・チェックリストに従い plan-doc.md を作成する
```

**architect への指示**:
```
あなたは設計担当エージェント「architect」です。
1. まずスキルファイルを読み込む: .claude/skills/architecture-design.md
2. 要件ドキュメントを読み込む: .claude/design-output/todo-app/requirement-doc.md
3. スキルのガイド・フォーマット・チェックリストに従い architecture-doc.md を作成する
```

**ポイント: 「固定ロールのエージェント」ではなく、「汎用エージェント + スキル参照」で専門家をその場で作っている。**

### エージェントの動き方

1. **planner**: スキルファイルを読み込み → ボトムアップ開発順序に従ったフェーズ別タスク分解を出力。タスク粒度は30分〜4時間に収まっていた。
2. **architect**: スキルファイルを読み込み → YAGNI 原則に従い、不要機能（フィルタリング、ドラッグ&ドロップ、Redux 等）を明示的に排除。1ファイル1責任のファイル構成を出力。
3. **reviewer**: 両方の成果物を読み込み → **plan-doc と architecture-doc の間の実際の矛盾を2つ検出**:
   - ファイルパスの不一致（`src/types/todo.ts` vs `src/types.ts`、`TodoInput` vs `TodoForm` 等）
   - YAGNI 違反の疑い（plan-doc に `createdAt` フィールドがあるが、要件にない）

### 検証結果

| 観点 | 結果 |
|------|------|
| スキルのフォーマット遵守 | 全エージェントがスキルで定義されたMarkdownフォーマットに従って出力した |
| 設計原則の遵守 | YAGNI、1ファイル1責任、ボトムアップ開発順序が守られた |
| レビューの品質 | 2つのドキュメント間の実際の矛盾を自力で発見。代替案も提示 |
| エージェント間の並行実行 | planner と architect が並行で稼働し、reviewer は依存関係通り完了後に起動 |
| 成果物の完成度 | 4つの設計ドキュメント（要件・計画・設計・レビュー）が全て正しく出力された |

---

## Skills の中身

### `/requirements-gathering` - 要件定義

ヒアリングの進め方（機能要件・非機能要件の質問テンプレート）、曖昧さの排除方法、既存システムの調査手順、成果物フォーマット、チェックリストを含む。

### `/task-planning` - タスク計画

タスク分解のルール（適切な粒度: 数時間〜2日）、ボトムアップ開発順序の原則、モック/スタブの活用方法、成果物フォーマット、チェックリストを含む。

### `/architecture-design` - アーキテクチャ設計

設計原則（YAGNI、1ファイル1責任、過度な抽象化の禁止、保守性）、設計の進め方、成果物フォーマット、チェックリストを含む。

### `/design-review` - 設計レビュー

レビュー観点（タスク粒度 → YAGNI → 抽象化 → 責任分離の重要度順）、問題発見時のユーザー確認フォーマット、成果物フォーマットを含む。

---

## 旧アプローチとの比較

| 比較項目 | 旧（プロンプトべた書き） | 新（Skills + CLAUDE.md） |
|----------|------------------------|-------------------------|
| ナレッジの配置 | 各エージェントのプロンプトに全部埋め込み | Skills に分離し、必要時だけ読み込む |
| エージェントの役割 | 4つの固定ロール | タスクに応じて動的に決定 |
| トークン効率 | 全知識が常にコンテキストに載る | 必要なスキルだけ読み込むので節約 |
| 柔軟性 | 4エージェント固定 | 1〜N エージェントを自由に構成 |
| フォーマット遵守 | 長大プロンプトの後半が無視されがち | 1スキル = 1責務で簡潔。守りやすい |
| 再利用性 | エージェント定義ごとに重複記述 | スキルは複数エージェントで共有可能 |

---

## 使い方

### 前提条件

```json
// settings.json
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}
```

### 設計フェーズの実行

Claude Code で以下のように指示する：

```
CLAUDE.md のワークフローに従って、TODOアプリの設計フェーズを実行してください。
```

CLAUDE.md がスキルの使い方を定義しているので、リーダーエージェントが自動的に：

1. `/requirements-gathering` を参照してユーザーにヒアリング
2. チームを作成し、タスクを割り当て
3. 各チームメイトに適切なスキル参照を指示
4. 成果物を `.claude/design-output/[project]/` に出力

### スキル単体での使用

Agent Teams を使わず、スキル単体でも利用可能。例：

```
/architecture-design スキルを参照して、この機能のファイル構成を設計してください。
```

必要なスキルだけ使えばいいので、小規模なタスクにも対応できる。

---

## 注意事項

- Agent Teams は実験的機能です
- 複数エージェントが動作するため、トークン使用量は多くなります（ただし旧アプローチより効率的）
- スキルの内容はプロジェクトに合わせてカスタマイズしてください
