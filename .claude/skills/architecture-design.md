# Skill: アーキテクチャ設計

このスキルは、**保守性とYAGNI原則**を重視した、実装可能なファイル構成・設計を作成するためのガイドです。

## いつ使うか

- ファイル構成やコンポーネント設計が必要なとき
- 技術的な設計判断が必要なとき
- チームメイトに設計ドキュメントを提供する必要があるとき

## 設計原則（重要度順）

### 1. YAGNI (You Aren't Gonna Need It)

- **今必要な機能だけを設計する**
- 将来の拡張性を過度に考慮しない
- 「もしかしたら使うかも」は含めない

```
NG: 「将来SMSも対応するかもしれないから、Notification抽象クラスを作ろう」
OK: 「今はメールだけ必要なので、email_notification.py を作る」
```

### 2. 1ファイル1責任

- 1つのファイルは1つの明確な責任のみ
- ファイルサイズ目安: 200-300行以内

```
NG: user_service.py (500行) - 登録、認証、プロフィール、パスワード変更
OK: user_registration.py (100行), user_authentication.py (80行), user_profile.py (70行)
```

### 3. 過度な抽象化を避ける

```
NG: BaseHandler, AbstractService, GenericRepository<T>, FactoryFactory
OK: UserService, ProductService → 必要になったら共通化
```

### 4. 保守性

- コードが読みやすく理解しやすいか
- 変更が容易か
- テストしやすいか

## 設計の進め方

1. **既存コードベースを調査する**（Glob, Grep, Read）
2. **最小限の機能を特定する**（YAGNI）
3. **ファイルを責任ごとに分割する**
4. **既存パターンとの整合性を確認する**

## 成果物フォーマット

以下のMarkdownフォーマットで `architecture-doc.md` を出力する：

```markdown
# アーキテクチャ設計: [機能名]

## 概要
[アーキテクチャの簡潔な説明]

## ファイル構成

### 新規作成
[folder]/
├── file_1.py  # [責任]
├── file_2.py  # [責任]
└── file_3.tsx # [責任]

### 修正するファイル
- `path/to/file` - [修正内容]

## 各ファイルの機能定義

### `path/to/file_1.py`
**責任**: [単一の責任]
**関数/クラス**:
- function_name(param: Type) -> ReturnType

## ファイル間の依存関係
file_1 → file_2 → file_3 のデータフロー

## API設計（該当する場合）
### POST /api/endpoint
- Request: { field: type }
- Response: { field: type }

## 設計の根拠
- なぜこのファイル構成を選択したか
- 既存パターンとの整合性
- YAGNI確認: 排除した「将来のための機能」

## テスト戦略
- 単体テスト: 各ファイルを独立テスト
- 統合テスト: API全体の動作テスト
```

## チェックリスト

設計を出す前に確認：

### YAGNI
- [ ] すべての機能が今本当に必要か？
- [ ] 「将来のため」の機能が含まれていないか？
- [ ] 過度な抽象化をしていないか？

### 1ファイル1責任
- [ ] 各ファイルの責任が明確か？
- [ ] 1ファイルに複数の機能が詰まっていないか？
- [ ] ファイルサイズが200-300行以内か？

### 保守性
- [ ] 読みやすく理解しやすいか？
- [ ] 変更が容易か？
- [ ] テストしやすいか？
- [ ] 既存パターンと一貫性があるか？
